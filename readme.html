<h1 id="mocha-ui-exports-request-build-status-https-secure-travis-ci-org-osher-mocha-ui-exports-request-png-branch-master-http-travis-ci-org-osher-mocha-ui-exports-request-">mocha-ui-exports-request <a href="http://travis-ci.org/osher/mocha-ui-exports-request"><img src="https://secure.travis-ci.org/osher/mocha-ui-exports-request.png?branch=master" alt="Build Status"></a></h1>
<h2 id="brief">Brief</h2>
<p>Use a DECLEARATIVE language for your HTTP request assertions, 
and get DESCRIPTIVE spec output from your mocha tests.</p>
<p>This is a unit-test helper for network request assertions, 
based on Mikael&#39;s <a href="https://github.com/mikeal/request">request</a> and <a href="https://github.com/visionmedia/should.js">should.js</a> of visionmedia, 
designed for the <a href="https://github.com/osher/mocha-ui-exports">mocha-ui-exports</a> plugin for <a href="https://github.com/visionmedia/mocha">mocha</a> test framework.</p>
<h2 id="content">Content</h2>
<ul>
<li><a href="#mocha-ui-exports-request">mocha-ui-exports-request</a><ul>
<li><a href="#brief">Brief</a></li>
<li><a href="#content">Content</a></li>
<li><a href="#use-case">Use Case</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#test">Test</a></li>
</ul>
</li>
<li><a href="#api">API</a><ul>
<li><a href="#request">request</a></li>
<li><a href="#requesttesterresponds">RequestTester#responds</a></li>
</ul>
</li>
<li><a href="#contribute">Contribute</a><ul>
<li><a href="#future">Future</a></li>
<li><a href="#lisence">Lisence</a></li>
</ul>
</li>
</ul>
<h2 id="use-case">Use Case</h2>
<p>Assume you have a cool http server that you want covered in BDD unit-tests,
and you want:</p>
<ul>
<li>high resolution DESCRIPTIVE test results</li>
<li>generated by a DECLARATIVE language</li>
</ul>
<p>Prequisites - you&#39;re programming in <a href="http://nodejs.org">node</a>, 
and using <a href="https://github.com/visionmedia/mocha">mocha</a> as test framework.</p>
<p><strong>Example</strong>
Lets just take for example - a notes application, that uses couch-db.
To make the example short, lets just assume 2 APIs: </p>
<ul>
<li>homepage - an HTML page</li>
<li>list-notes - an AJAX call</li>
<li>post-note - an AJAX call</li>
</ul>
<p>You want DESCRIPTIVE test results that follow the BDD principal that makes it 
as readable as specifications.
One that looks, for example, like that:</p>
<pre><code>  ./lib/server.js
    homepage - /
      with no parameters
        √ should return status 200
        √ should emit http-header: &#39;content-type&#39; as text/html
        √ body should match : /&lt;h1&gt;Your notes&lt;\/h1&gt;/
    ajax - /ajax/listnotes
      with no parameters - should return the 5 latest notes
        √ should return status 200
        √ should emit http-header: &#39;content-type&#39; as text/json
        √ body should be : &#39;{&quot;notes&quot;:[{&quot;date&quot;:1396257...&#39;
      with &#39;to&#39; - should return the next page in fixture
        √ should return status 200
        √ should emit http-header: &#39;content-type&#39; as text/json
        √ body should be : &#39;{&quot;notes&quot;:[{&quot;date&quot;:1396257...&#39;
      with &#39;to&#39; and &#39;from&#39; - should return the cut
        √ should return status 200
        √ should emit http-header: &#39;content-type&#39; as text/json
        √ body should be : &#39;{&quot;notes&quot;:[{&quot;date&quot;:1396257...&#39;
    ajax - /ajax/postnote
      with valid form - should accept the note
        √ should return status 200
    all expected couch-db hits
      √ should have been called

  14 passing (81ms)
</code></pre><p>But you want to express your mocha tests in a DECLERATIVE way.
Declarative - means:</p>
<ul>
<li>avoid flow-control</li>
<li>avoid logic</li>
<li>stick with declaration </li>
<li>stick with descriptions
No ifs, no elses, no loops, and as few add-hock custom callbacks as possible.</li>
</ul>
<p>Ah, assume you want to cover the back-end requests too, and use for that purpose, for example <a href="https://github.com/pgte/nock">nock</a>.</p>
<p>How would you feel if I tould you that you can do it this way:</p>
<pre><code>    // the test target
var svr = require(&#39;../server&#39;) 
    //the helper
  , request =require(&#39;mocha-ui-exports-request&#39;)
    //plugs the recorded scenario of http requests to couch
  , nock =  require(&#39;fixtures/nock&#39;)
  ;

svr.listen(1234);

module.exports = 
{ &quot;./lib/server.js&quot; : 
  { &quot;homepage - /&quot; :
    { &quot;with no parameters&quot; :
      request(&quot;http://127.0.0.1:1234/&quot;)
      .responds(
        { status: 200
        , headers: 
          { &quot;content-type&quot; : &quot;text/html&quot;
          }
        , body: /&lt;h1&gt;Your notes&lt;\/h1&gt;/
        }
      )
    }
  , &quot;ajax - /ajax/listnotes&quot; :
    { &quot;with no parameters - should return the 5 latest notes in fixture&quot; :
      request(&quot;http://127.0.0.1:1234/ajax/listnotes&quot;)
      .responds(
        { status : 200
        , headers: 
          { &quot;content-type&quot; : &quot;text/json&quot;
          }
        , json:  
          { notes : 
            [ { date: new Date(&#39;2014-04-02T15:35:55.754&#39;).getTime()
              , note: &quot;note 1&quot; 
              }
            , { date: new Date(&#39;2014-04-02T05:22:41.832&#39;).getTime()
              , note: &quot;note 2&quot; 
              }
            , { date: new Date(&#39;2014-04-01T21:03:43.004&#39;).getTime()
              , note: &quot;note 3&quot; 
              }
            , { date: new Date(&#39;2014-04-01T13:55:48.123&#39;).getTime()
              , note: &quot;note 4&quot; 
              }
            , { date: new Date(&#39;2014-04-01T08:14:31.631&#39;).getTime()
              , note: &quot;note 5&quot; 
              }
            ] 
          }
        }
      )
    , &quot;with &#39;to&#39; - should return the next page in fixture&quot; :
      request(&quot;http://127.0.0.1:1234/ajax/listnotes/to/2014-03-31/&quot;)
      .responds(
        { status: 200
        , headers: 
          { &quot;content-type&quot; : &quot;text/json&quot;
          }
        , json: 
          { notes : 
            [ { date: new Date(&#39;2014-03-31T09:21:55.331&#39;).getTime()
              , note: &quot;note 6&quot; 
              }
            , { date: new Date(&#39;2014-03-30T06:21:55.784&#39;).getTime()
              , note: &quot;note 7&quot; 
              }
            , { date: new Date(&#39;2014-03-29T18:13:41.575&#39;).getTime()
              , note: &quot;note 8&quot; 
              }
            ] 
          }
        }
      )
    , &quot;with &#39;to&#39; and &#39;from&#39; - should return the cut&quot; :
      request(&quot;http://127.0.0.1:1234/ajax/listnotes/from/2014-03-30/to/2014-03-30/&quot;)
      .responds(
        { status: 200
        , headers: 
          { &quot;content-type&quot; : &quot;text/json&quot;
          }
        , json: 
          { notes : 
            [ { date: new Date(&#39;2014-03-30T06:21:55.784&#39;).getTime()
              , note: &quot;note 7&quot; 
              }
            ]
          }
        }
      )
    }
  , &quot;ajax - /ajax/postnote&quot; :
    { &quot;with valid form - should accept the note&quot; :
      request(
        { uri : &quot;http://127.0.0.1:1234/ajax/postnote&quot;
        , form: 
          { note : &quot;note 9&quot;
          }
        }
      ).responds(
        { status: 200
        }
      )
    }
  , &quot;all expected couch-db hits&quot; :
    { &quot;should have been called&quot; :
       function(){
          nock.done()
       }
    }
  }
}
</code></pre><h2 id="install">Install</h2>
<pre><code>npm install mocha-ui-exports-request
</code></pre><p>ok, long name. I will accept better offers...</p>
<h2 id="test">Test</h2>
<p>the published package is slim: it does not contain the test suite.
You&#39;ll have to clone this repo, to <code>npm install</code> from within the cloned folder, and then to <code>npm test</code>.</p>
<h1 id="api">API</h1>
<h2 id="request">request</h2>
<p><code>request(reqOptions) : RequestTester</code>
It builds a requet-tester for the provided <code>reqOptions</code>.</p>
<p><code>reqOptions</code> - any options setting valid for mikael&#39;s <a href="https://github.com/mikeal/request">request</a> module, including form, post-data, multiplart, and whatever you want.</p>
<p><code>RequestTester</code> - implements one method: <code>RequestTester#responds</code>, that returns a <a href="https://github.com/osher/mocha-ui-exports">mocha-ui-exports</a> suite, who&#39;s setup function will fire the request, and hold it in context closure for all the asserts that follow.</p>
<h2 id="requesttester-responds">RequestTester#Responds</h2>
<p><code>reqTester#responds(options) : suite</code>
It builds an asserter for every one of the options provided.
Supported options:</p>
<h3 id="options-status">options.status</h3>
<p>assert a status code. generates <em>&quot;should return status ...&quot;</em> asserts.</p>
<p>Example: </p>
<pre><code>module.exports = {
  &#39;/my/resource&#39; : 
    request( &#39;http://my-sut-server.com/my/resource&#39; )
    .responds( {
      status: 200
    })
}
</code></pre><p>becomes:</p>
<pre><code>/my/resource
   √ should return status 200
</code></pre><h3 id="options-headers">options.headers</h3>
<p>asserts against headers in the headers collection. generates <em>&quot;should emit http-header: &#39;xxx&#39; as yyy&quot;</em> asserts
    keys are expected HTTP-headers, values can be strings to compare to, or RegExps to match with.</p>
<p>Example:</p>
<pre><code>module.exports = module.exports = {
  &#39;/my path&#39; : 
    request( &#39;http://my-sut-server.com/my-path&#39; )
    .responds( {
      headers: { 
        &#39;x-powered-by&#39; : &#39;my cool server&#39;
        etag : /.*/
      }
    })
}
</code></pre><p>becomes:</p>
<pre><code>/my-path
   √ should emit http-header: &#39;x-powered-by&#39; as &#39;my cool server&#39;
   √ should emit http-header: &#39;etag&#39; as /.*/
</code></pre><h3 id="options-responseheaders">options.responseHeaders</h3>
<p>For add-hock assertions that should be performed against the <em>entire</em> headers collection, 
and cannot be expressed as descrete assertions against a single http header.
The test titles in this case are your responsibility. Your tests will be grouped under &#39;response headers&#39; section
The value of this entry should be an object where every key is a test-tile, and every value 
is a function that accepts the <code>response.headers</code> collection and performs add-hock assertions against it.</p>
<p>Example:</p>
<pre><code>module.exports = module.exports = {
  &#39;/my path&#39; : 
    request( &#39;http://my-sut-server.com/my-path&#39; )
    .responds( {
      responseHeaders: { 
        &#39;must contain either x-powered-by or x-server-type&#39; : function(headers) {
            Should( headers[&#39;x-powered-by&#39;] || headers[&#39;x-server-type&#39;]).be.ok
        }
      }
    })
}
</code></pre><p>becomes:</p>
<pre><code>/my-path
    response headers
      √ must contain either x-powered-by or x-server-type
</code></pre><h3 id="options-body">options.body</h3>
<p>an array of body asserts. Assertions may be:</p>
<ul>
<li><code>string</code> - asserts that the body is equal to the given <code>string</code> value, under title like : <em>&quot;body should be : {your assertion value}&quot;</em>.
   When the given value is longer than 20 chars the remnant is cut and appended with ellipis (...).</li>
<li><code>RegExp</code> - asserts that the body matches the given <code>RegExp</code> value, under title like <em>&quot;body should match: ...&quot;</em></li>
<li><code>object</code> - this is a suite object, where every key is a test tile, and every value is a test-funciton that expects the body, 
   and lets you write whatever add-hock tests you need. In this case, the test titles are your responsibility.</li>
<li><code>Array</code> - a combination of any of the above.</li>
</ul>
<p>Example:</p>
<pre><code>module.exports = module.exports = {
  &#39;/my path&#39; : 
    request( &#39;http://my-sut-server.com/index.html&#39; )
    .responds( {
      body: [
        /&lt;h3&gt;Hello Anonymous&lt;/h3&gt;/,
        /&lt;h2&gt;Our Catalog&lt;/h2&gt;/,
        { &#39;should contain 3 promoted products&#39; : function(body) { 
              var n = 0;
              body.replace(/class=&quot;promotedProduct&quot;/, function() { n++ } );
              n.should.eql(3)
          }
        }
      ]
    })
}
</code></pre><p>becomes:</p>
<pre><code>/my-path
   √ body should match: /&lt;h3&gt;Hello Anonymous&lt;/h3&gt;/
   √ body should match: /&lt;h2&gt;Our Catalog&lt;/h2&gt;/
   response body
      √ sould contain 3 promoted products
</code></pre><h3 id="options-json">options.json</h3>
<p>When provided - it is stringified and treated a a string body asserter.</p>
<p>Example: </p>
<pre><code>module.exports = {
  &#39;/api/search&#39; : 
    &#39;search for non existing product&#39; : 
      request( &#39;http://my-sut-server.com/search?no-such-product&#39; )
      .responds( {
        json: { products: [ ] }
      })
    },
    &#39;search for specific existing product&#39; : 
      request( &#39;http://my-sut-server.com/search?no-such-product&#39; )
      .responds( {
        json: { products: [ { name: &#39;XL yellow T-Shirt&#39;, description: &#39;a very cool shirt, organic materials, very comfortable, loved by our customers&#39; } ] }
      })
    }
  }
}
</code></pre><p>becomes:</p>
<pre><code>/api/search 
   search for non existing product
      √ body should be &#39;{ products: [ ] }&#39;
   search for specific existing product
      √ body should be &quot;{&quot;products&quot;:[{&quot;name&quot;...&quot;
</code></pre><h3 id="options-err">options.err</h3>
<p>Assert an expected error for your request. </p>
<ul>
<li>Mind that it&#39;s a network error, and not HTTP error. HTTP errors are checked with <code>options.status</code>.</li>
<li>it&#39;s useful in wierd edge-cases, for example, when you want to test that the server instance terminates
in response to a shutdown request by an authenticated administrator.</li>
</ul>
<h3 id="options-and">options.and</h3>
<p>a subsuite of add-hock custom assertions, performed against the entire response object.
The value should be an object where every key is a test-tile, and every value is a function that accepts the <code>response</code> 
object and performs add-hock assertions against it.</p>
<p>Example: </p>
<pre><code>module.exports = {
  &#39;/api/wierd&#39; : {
    request(&#39;http://my-sut-server.com/search?no-such-product&#39;)
    .responds({
      headers: { 
        &#39;x-powered-by&#39; : &#39;my cool server&#39;
        etag : /.*/
      },
      and: {
        &#39;should redirect header, or the resource&#39; : function(res) {
            Should.be.ok(
              res.status == 302 ||
              res.status == 200 &amp;&amp; res.headers[&#39;content-type&#39;] == &#39;application/json&#39; 
            )
        }
      }
    })
  }
}
</code></pre><p>becomes:</p>
<pre><code>
/api/wierd
   √ should emit http-header: &#39;x-powered-by&#39; as &#39;my cool server&#39;
   √ should emit http-header: &#39;etag&#39; as /.*/
   and
      √ should give a redirect header, or the resource
</code></pre><p>For more detailed API spec - don&#39;t dig for docs - run the <a href="#test">test</a>, just like the BDD lore sais...
Have fun ;)</p>
<h1 id="contribute">Contribute</h1>
<p>Sure, why not. That&#39;s why it&#39;s here ;)</p>
<h2 id="future">Future</h2>
<ul>
<li>negated assertions (status is not..., body does not contain...)</li>
<li>handle timeouts</li>
</ul>
<h2 id="lisence">Lisence</h2>
<ul>
<li>MIT</li>
</ul>

